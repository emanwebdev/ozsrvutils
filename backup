#!/bin/bash

###
# OpenZula server utilities
# --- Backups domains, emails and some system files using "duplicity"
#
# @author Alex Cartwright <alex@openzula.org>
# @copyright Copyright (C) 2010 OpenZula
# @license http://www.gnu.org/licenses/old-licenses/gpl-2.0.html GNU/GPL 2
###

if (( $(which duplicity &> /dev/null; echo $?) > 0 )); then
	echo "One or more of the following commands can not be found: duplicity" >&2
	exit 2
fi

case $2 in
	--cron|--domains|--emails|--mysql)
		action=${2:2}
		;;
	-h)
		echo "OpenZula server utilities"
		echo "Usage:"
		echo -e "\t$scriptName backup --cron"
		echo -e "\t$scriptName backup --domains"
		echo -e "\t$scriptName backup --emails"
		echo -e "\t$scriptName backup --mysql\n"
		echo "Report bugs to <alex@openzula.org>"
		exit 0
		;;
	*)
		echo "Invalid action '$2'. Use '--cron', '--domains', '--emails' or '--mysql'" >&2
		exit 1
		;;
esac

if [[ -z $cfgBackupDest ]]; then
	echo "No backup destination 'cfgBackupDest' has been set" >&2
	exit 2
fi

##
## Set various environmental variables & duplicity arguments
##
export PASSPHRASE=$cfgBackupPassphrase

# GPG encryption & signing (advised)
if [[ -n $cfgBackupGpgKey ]]; then
	duplicityArgs=(--encrypt-key="$cfgBackupGpgKey" --sign-key="$cfgBackupGpgKey")
else
	duplicityArgs=(--no-encryption)
fi

# Amazon S3 specific configuration
if [[ -n $cfgBackupS3SecretKey ]]; then
	export AWS_ACCESS_KEY_ID=$cfgBackupS3Key AWS_SECRET_ACCESS_KEY=$cfgBackupS3SecretKey
	if [[ $cfgBackupS3European = true ]]; then
		duplicityArgs+=(--s3-use-new-style --s3-european-buckets)
	elif [[ $cfgBackupS3NewStyle = true ]]; then
		duplicityArgs+=(--s3-use-new-style)
	fi
fi

duplicityArgs+=("${cfgBackupDuplicityArgs[@]}")

##
## Backup all of the required paths
##
## @param string source ($1)
## @param string realm ($2)
## @param string destination ($3)	If empty the source will be used
##
duplicityBackupPath()
{
	duplicity \
		--verbosity warning \
		--no-print-statistics \
		--full-if-older-than 1M \
		--volsize 100 \
		"${duplicityArgs[@]}" \
		"$1" \
		"$cfgBackupDest/$2/${3:-$1}"
	if (( $? > 0 )); then
		echo "Failed to backup '$1'" >&2
		return 2
	else
		echo "Successfully backed up '$1'"
		duplicity \
			remove-older-than "${cfgBackupTtl:-6M}" \
			--verbosity warning \
			--force \
			"${duplicityArgs[@]}" \
			"$cfgBackupDest/$2/${3:-$1}"
		if (( $? > 0 )); then
			echo "Failed to remove older files in '$2/$1'" >&2
			return 2
		else
			return 0
		fi
	fi
}

if [[ $action = domains ]]; then
	for credentialsFile in "$cfgVarStateDir"/domains/*; do
		# Get the path of the domain name
		domainPath=$(awk '/^path =/{print $3}' "$credentialsFile")
		if [[ -z $domainPath || ! -d $domainPath ]]; then
			echo "Malformed or nonexistent 'path' value in '$credentialsFile'" >&2
			exitCode=2
		else
			duplicityBackupPath "$domainPath" domains
			if (( $? > 0 )); then
				exitCode=2
			fi
		fi
	done
elif [[ $action = cron || $action = emails ]]; then
	if [[ $action = cron ]]; then
		sourcePath=/var/spool/cron
	elif [[ $action = emails ]]; then
		sourcePath=/var/mail/virtual
	fi
	if [[ ! -d $sourcePath ]]; then
		echo "Unable to find '$sourcePath'" >&2
		exitCode=2
	else
		duplicityBackupPath $sourcePath $action
		if (( $? > 0 )); then
			exitCode=2
		fi
	fi
elif [[ $action = mysql ]]; then
	# Backup all the domain databases
	tmpDir=$(mktemp -d --tmpdir ozsrvutils-mysql.XXX)
	for credentialsFile in "$cfgVarStateDir"/domains/*; do
		dbUser=$(awk '/^mysql_username =/{print $3}' "$credentialsFile")
		dbPass=$(awk '/^mysql_password =/{print $3}' "$credentialsFile")
		dbName=$(awk '/^mysql_database =/{print $3}' "$credentialsFile")
		if [[ -n $dbUser && -n $dbPass && -n $dbName ]]; then
			# Dump the MySQL database to a tmp file
			tmpFile=$tmpDir/$dbName.sql.gz
			(umask 177 && touch "$tmpFile")
			mysqldump \
				--host="$cfgMysqlHost" \
				--user="$dbUser" \
				--password="$dbPass" \
				--lock-tables \
				--skip-extended-insert \
				"$dbName" | gzip > "$tmpFile"
			# Back up the tmp file
			duplicityBackupPath "$tmpFile" mysql "$dbName"
			unlink "$tmpFile"
		fi
	done
	# A little house keeping
	rm -rf "$tmpDir"
fi

unset PASSPHRASE AWS_ACCESS_KEY AWS_SECRET_ACCESS_KEY

exit ${exitCode:-0}